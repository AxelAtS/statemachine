require 'statemachine/generate/util'
require 'statemachine/generate/src_builder'

module Statemachine
  class Statemachine

    attr_reader :states

    def to_java(options = {})
      generator = Generate::Java::JavaStatemachine.new(self, options)
      generator.generate!
    end

  end

  module Generate
    module Java
      class JavaStatemachine

        include Generate::Util

        HEADER1 = "// This file was generated by the Ruby Statemachine Library (http://slagyr.github.com/statemachine)."
        HEADER2 = "// Generated at "

        def initialize(sm, options)
          @sm = sm
          @output_dir = options[:output]
          @classname = options[:name]
          @context_classname = "#{@classname}Context"
          @package = options[:package]
          raise "Please specify an output directory. (:output => 'where/you/want/your/code')" if @output_dir.nil?
          raise "Output dir '#{@output_dir}' doesn't exist." if !File.exist?(@output_dir)
          raise "Please specify a name for the statemachine. (:name => 'SomeName')" if @classname.nil?
        end

        def generate!
          explore_sm
          create_file(src_file(@classname), build_statemachine_src)
          create_file(src_file(@context_classname), build_context_src)
        end

        private ###########################################

        def explore_sm
          @state_names = @sm.states.keys.reject{|k| k.nil? }.map { |id| id.to_s.camalized }.sort

          events = []
          actions = []
          @sm.states.values.each do |state|
            state.transitions.values.each do |transition|
              events << transition.event
              add_action(actions, transition.action)
            end
          end
          @event_names = events.uniq.map {|e| e.to_s.camalized(:lower)}.sort

          @sm.states.values.each do |state|
            add_action(actions, state.entry_action)
            add_action(actions, state.exit_action)
          end
          @action_names = actions.uniq.map {|e| e.to_s.camalized(:lower)}.sort
        end

        def add_action(actions, action)
          return if action.nil?
          raise "Actions must be symbols in order to generation Java code. (#{action})" unless action.is_a?(Symbol)
          actions << action
        end

        def build_statemachine_src
          src = begin_src
          src << "public class #{@classname}" << endl
          begin_scope(src)

          add_state_instances(src)
          add_statemachine_boilerplate_code(src)
          add_event_delegation(src)
          add_statemachine_exception(src)
          add_base_state(src)
          add_state_implementations(src)

          end_scope(src)
          return src.to_s
        end

        def add_state_instances(src)
          src << "// State instances" << endl
          @state_names.each do |state|
            src << "public final State #{state.upcase} = new #{state}State(this);" << endl
          end
          src << "private State state = #{default_state_name};" << endl
          src << endl
        end

        def add_statemachine_boilerplate_code(src)
          src << "// The following is boiler plate code standard to all statemachines" << endl
          src << "private #{@context_classname} context;" << endl
          src << endl
          add_one_liner(src, nil, @classname, "#{@context_classname} context", "this.context = context")
          add_one_liner(src, @context_classname, "getContext", nil, "return context")
          add_one_liner(src, "State", "getState", nil, "return state")
          add_one_liner(src, "void", "setState", "State newState", "state = newState")
        end

        def add_event_delegation(src)
          src << "// Event delegation" << endl
          @event_names.each do |event|
            add_one_liner(src, "void", event, nil, "state.#{event}()")
          end
        end

        def add_statemachine_exception(src)
          src << "// Standard exception class added to all statemachines." << endl
          src << "public static class StatemachineException extends RuntimeException" << endl
          begin_scope(src)
          src << "public StatemachineException(State state, String event)" << endl
          begin_scope(src)
          src << "super(\"Missing transition from the '\" + state.getClass().getName() + \"' state with the '\" + event + \"' event.\");" << endl
          end_scope(src)
          end_scope(src)
          src << endl
        end

        def add_base_state(src)
          src << "// The base state" << endl
          src << "public static abstract class State" << endl
          begin_scope(src)
          src << "protected #{@classname} statemachine;" << endl
          src << endl
          add_one_liner(src, nil, "State", "#{@classname} statemachine", "this.statemachine = statemachine")
          @event_names.each do |event|
            add_one_liner(src, "void", event, nil, "throw new StatemachineException(this, \"#{event}\")")
          end
          end_scope(src)
          src << endl
        end

        def add_state_implementations(src)
          src << "// State implementations" << endl
          @sm.states.keys.sort.each do |state_id|
            add_state_class(src, state_id) if state_id
          end
        end

        def add_state_class(src, state_id)
          state = @sm.states[state_id]
          state_name = state_id.to_s.camalized
          src << "public static class #{state_name}State extends State" << endl
          src << "{" << endl
          src.indent!
          add_one_liner(src, nil, "#{state_name}State", "#{@classname} statemachine", "super(statemachine)")
          state.transitions.keys.sort.each do |event_id|
            add_state_event_handler(event_id, src, state)
          end
          src.undent!
          src << "}" << endl
          src << endl
        end

        def add_state_event_handler(event_id, src, state)
          transition = state.transitions[event_id]
          event_name = event_id.to_s.camalized(:lower)
          add_method(src, "void", event_name, nil) do
            if transition.action
              src << "statemachine.getContext().#{transition.action.to_s.camalized(:lower)}();" << endl
            end
            src << "statemachine.setState(statemachine.#{transition.destination_id.to_s.upcase});" << endl
          end
        end

        def add_one_liner(src, return_type, name, params, body)
          add_method(src, return_type, name, params) do
            src << "#{body};" << endl
          end
        end

        def add_method(src, return_type, name, params)
          src << "public #{return_type} #{name}(#{params})".sub('  ', ' ') << endl
          begin_scope(src)
          yield
          end_scope(src)
          src << endl
        end

        def begin_scope(src)
          src << "{" << endl
          src.indent!
        end

        def end_scope(src)
          src.undent! << "}" << endl
        end

        def default_state_name
          @sm.startstate.nil? ? "null" : @sm.startstate.to_s.upcase
        end

        def build_context_src
          src = begin_src
          src << "public interface #{@context_classname}" << endl
          begin_scope(src)
          src << "// Actions" << endl
          @action_names.each do |event|
            src << "void #{event}();" << endl
          end
          end_scope(src)
          return src.to_s
        end

        def begin_src
          src = SrcBuilder.new
          src << HEADER1 << endl
          src << HEADER2 << timestamp << endl
          src << "package #{@package};" << endl
          src << endl
          return src
        end

        def create_file(filename, content)
          establish_directory(File.dirname(filename))
          File.open(filename, 'w') do |file|
            file.write(content)
          end
        end

        def src_file(name)
          path = @output_dir
          if @package
            @package.split(".").each { |segment| path = File.join(path, segment) }
          end
          return File.join(path, "#{name}.java")
        end

      end
    end
  end
end